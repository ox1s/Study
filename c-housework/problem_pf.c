#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
/*
Problem PF -- простые числа, подобные числам Фибоначчи

Некоторые числа Фибоначчи, например 5 и 13 являются также простыми числами

Поскольку многие числа Фибоначчи довольно велики (например 99194853094755497 и даже 2880067194370816120 вполне входят в 64 бита), проверить их на простоту прямой проверкой может быть нелегко, а памяти на решето не хватит. Поэтому можно использовать статистические тесты из прошлых упражнений (такие как тест Ферма). Но для маленьких чисел простая проверка все ещё эффективней

Разумеется, список простых чисел Фибоначчи не слишком интересен, его легко нагуглить

2, 3, 5, 13, 89, 233, 1597, 28657, 514229, 433494437, 2971215073, 99194853094755497, ....

К счастью, в мире много других интересных последовательностей, похожих на числа Фибоначчи, например такая:

Seq0 = 0

Seq1 = 1

Seqi = k * Seqi - 1 + n * Seqi - 2

Ваша задача, получив на вход числа k и n вычислить самое большое простое число P, такое, что P < 260 и P входит в данную последовательность

Вы можете быть уверены, что k и n целые, положительные и не слишком большие (меньше чем 256 каждое)

Посылка должна состоять из программы, считывающей со стандартного ввода k и n и выводящей на стандартный вывод P

Вполне может быть и так, что в последовательности нет простых чисел. Тогда вы должны вывести на стандартный вывод 0
*/

int main() {
    int n;
    int res = scanf("%d", &n);
    if (res != 1) {
        printf("Wrong input!");
        abort();
    }
    return 0;
}
